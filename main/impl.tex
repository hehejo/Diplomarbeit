\chapter{Prototypische Implementierung}
\label{chap:impl}

Our prototypic implementation of the introduced models shows, the applicability of this optimization approach to a channel based publish/subscribe system. We choose C++ as language of choice and we use Chimera \cite{Allen2006Chimera}, a structured p2p-overlay system written in C. In order to minimize the overhead introduced by the flexibility of such a framework e.g. on message size or stack depth caused by function calls, we use \ac{tmp} and \emph{policy based}-design \cite{Alexandrescu2001Modern} to create the optimized channels at compile-time. The different optimization strategies for each dimension are implemented as policies encapsulating their behaviour. Each channel is therefore a template class with all dimensions as template parameters, which are instantiated with strategies for each parameter.  

With \ac{tmp} it is possible to derive create custom-tailored message headers, depending on the chosen strategies. This ensures small message sizes with a high payload ratio. Each channel itself is therefore in charge to orchestrate strategies for the different policies with regard to our processing model, derived by the semantic description for all optimization dimensions. All described design decisions ensure that the system has a small footprint at runtime and that it can be used without further knowledge of the system internals, the channels or the used strategies.

\input{main/impl_tmp.tex}

\section{Implementierungsdetails}

\begin{figure}[htbp]
\centering
\resizebox{\textwidth}{!}{%
\includegraphics{grafics/uml.pdf}}
\caption{vereinfachtes Klassendiagramm des Frameworks}
\label{fig:uml}
\end{figure}

\emph{P2PInterface} ist eine abstrakte Basisklasse und repräsentiert die in \cite{Dabek2003Towards} beschrieben KBR-API. Aktuell wird diese vom \emph{ChimeraWrapper} implementiert, der über den \emph{ChimeraWrapperImpl} mit dem Netzwerk Chimera spricht. Hier wurde das ``PIMPL''-Pattern angewandt, mit dem die eigentliche Implementierung versteckt werden kann \cite{Alexandrescu2001Modern}. Die \emph{Applikation} spricht mit dem \emph{PubSubSytem}, dessen Implementierung auch in einer eigenen Klasse ausgelagert ist. Die Applikation und das PubSubSystem kennen den \emph{Channel} nur über die abstrakte Basisklasse \emph{IChannel} beziehungsweise \emph{IChannelOwn}. Durch diese beiden Basisklassen wird die Komplexität der durch Policies optimierten Klasse Channel verdeckt. Die Klasse \emph{PubSubController} implementiert das Interface \emph{P2PCallback} und kann sich somit für die Callbacks des Netzwerkes registrieren. Weiterhin bietet diese Klasse die von Channel benötigte Funktionalität. PubSubSystemImpl kennt die Netzwerkwrapperklassen (in \Fref{fig:uml} ChimeraWrapper) und verbindet diese über den PubSubController mit dem Channel. Mit verschiedene Instanzen des PubSubControllers können somit auch verschiedene Netzwerke angesprochen werden und entsprechend der Optimierung für verschiedene Channel eingesetzt werden.

\subsection{Netzwerkabstraktion}
\begin{itemize*}
\item Abstrakte Basisklasse für Netzwerk
\item Abstrakte Basisklasse für Netzwerkupcalls
\item Wrapperklassen für jedes Netzwerk
\end{itemize*}


\subsection{PubSubabstraktion}
\begin{itemize*}
\item PubSubController spricht mit Netzwerk
\item PubSubSystem spricht mit Applikation und leitet Anfragen an Channel weiter
\item Channel nutzt Controller zum Netzwerkzugriff
\item $\rightarrow$ Möglichkeit verschiedene Netzwerke zu nutzen!
\end{itemize*}

\subsection{Channel}
\begin{itemize*}
\item Channel mit TMP und policy-based Design
\item viele verschiedene Strategien
\end{itemize*}

\lstinputlisting[caption={\ac{m2etis} aus Benutzersicht}, label=lst:pubsub_usage]{listings/pubsub_usage.cpp}
